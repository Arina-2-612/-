# Проектная (учебная) практика 2025.
Создание Telegram бота с помощь языка программирования Python.
### Актуальность Telegram ботов. Бот для подбора продуктов потребления. Бот для подбора фильма.
Telegram-боты становятся всё более популярными благодаря удобству использования, автоматизации процессов и персонализации сервисов. В данном исследовании рассматривается актуальность ботов, предназначенных для подбора фильмов на основе предпочтений пользователя.

Telegram-бот для подбора фильмов – актуальный и востребованный продукт, особенно если он предлагает персонализированные рекомендации и удобный интерфейс. Несмотря на конкуренцию, нишевые решения с уникальными функциями могут занять свою аудиторию.

Рекомендации для разработки:

* Использовать ML для точных рекомендаций.
* Добавить интеграцию с популярными кинобазами.
* Сделать интерфейс максимально простым и интерактивным.

Анализ рынка Telegram-ботов для подбора фильмов
Существующие аналоги:

@MovieFinderBot – подбор фильмов по жанру, году, рейтингу.
@FilmAdvisorBot – рекомендации на основе оценок пользователя.
@KinopoiskBot – интеграция с Кинопоиском для поиска фильмов.

Большинство ботов предлагают базовый функционал, но не всегда используют сложные алгоритмы рекомендаций (например, на основе машинного обучения).

Потенциальная аудитория
* Киноманы, желающие открывать новые фильмы.
* Люди, испытывающие трудности с выбором фильма.
* Пользователи, предпочитающие быстрый и удобный сервис без рекламы.

### Техническое руководство для начинающих.

###### Теоретическая часть. Техническое задание на разработку Telegram-бота.

Описание:
Телеграм бот “FilmBot” предназначен для подбора 1-3 фильмов по запросам пользователя. Бот предлагает варианты ответа по трём критерием (жанр, настроение, длительность) и на основании ответов определяет, какой пункт подходит пользователю и выводит его на экран.

Общие требования

1.	Стековые технологии:

*  Язык программирования: Python
* Среда программирования: PyCharm
* Хостинг: GitHub
* Создание Markdown файла: VS Code
* Расширение: Markdown All in One

2.	Функциональные требования

Необходима только одна команда:

/start 
Начинает диалог с пользователем и выводит фразу: 

"Привет, (имя пользователя) Я подберу фильм по твоим предпочтениям ❤️\n\n'
"Выбери один из основных жанров в меню: "

3.	База данных с информацией про фильмы.
movies_db = [
    {"title": "Крестный отец", "genre": "криминал", "mood": "напряжённый", "duration": "длинный"},
    {"title": "Побег из Шоушенка", "genre": "драма", "mood": "добрый", "duration": "длинный"},
    ...
]
4.	Варианты жанров: боевик, драма, комедия, фантастика, криминал, триллер.
5.	Варианты настроения: романтический, экшн, добрый, напряжённый, весёлый, психологический.
6.	Варианты длительности: короткий, средний, длинный, любой.

###### Практическая часть. Этапы разработки

1.	Настройка окружения

* Установка языка программирования Python 3.9+
* Установка среды программирования PyCharm
* Создание нового проекта, название Bot_practic
* Подключение библиотеки в терминале библиотеки для установления зависимости:

![alt text](<Снимок экрана 2025-05-21 001423-1.png>)

2.	Создание телеграм бота

Переходим непосредственно в приложение Telegram и находим @BotFather – официального бота для создания, оформления и редактирования ботов. Затем вводим программы /start для открытия меню и /newBot для создания своего бота. Далее придумываем название и юзернейм, после чего бот будет создан, мы получаем его токен (он будет использоваться в коде).
Далее настраиваем фото и описание и получаем готовый внешний вид будущего бота.

3.	Написание программы для бота

Импортируем библиотеки:

*from telegram import ReplyKeyboardMarkup, ReplyKeyboardRemove, Update
from telegram.ext import (
    Application,
    CommandHandler,
    ConversationHandler,
    MessageHandler,
    filters,
    ContextTypes,
)*

Где:

•	ReplyKeyboardMarkup - для удобного выбора вариантов
•	ConversationHandler - для управления многоэтапным диалогом
•	MessageHandler - для обработки текстовых сообщений

Определяем состояния диалога:

*GENRE, MOOD, DURATION, RESULT = range(4)*

Создание базы данных фильмов (идентично тому, как прописано в ТЗ):
Далее создаём функцию start(), в которой определяем имя пользователя: 

*user = update.effective_user*

Вводим меню вариантов жанров, причём оформляем в две строчки с помощью квадратных скобок для лучшего визуала:

*reply_keyboard = ["боевик", "драма", "комедия","фантастика", "криминал", "триллер"]*

Далее приветствуем пользователя, выводя начальную строчку и переходим в состояние жанра:

*return GENRE*

В итоге получается:

![alt text](<Снимок экрана 2025-05-21 001736-1.png>)

Создаём функцию genre, в котором выводим меню с вариантами жанров, обрабатываем выбор и выводим строчку, обозначающую переход к следующему состоянию – настроению.

![alt text](<Снимок экрана 2025-05-21 002540-1.png>)

По аналогии создаём функцию mood() для определения настроения, меняя только данные.

Функция duration повторяет элементы предыдущих функций:

 *async def duration(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    reply_keyboard = ["короткий", "средний", "длинный", "любой"]*

А также добавляются следующие элементы:
* Присваивание значений выбранных вариантов
* Цикл для подбора фильмов
* Обработчик событий: в случае того, если фильм не будет найден – выводится случайный фильм:
* Ограничение вывода максимум 3-х фильмов
* Вывод подобранного фильма
  

        genre_pref = context.user_data.get("genre", "")
        mood_pref = context.user_data.get("mood", "")
        duration_pref = context.user_data.get("duration", "любой")

        # цикл для подбора фильма
        suitable_movies = []
        for movie in movies_db:
            genre_match = not genre_pref or genre_pref in movie["genre"]
            mood_match = not mood_pref or mood_pref in movie["mood"]
            duration_match = (duration_pref == "любой") or (duration_pref in movie["duration"])

            if genre_match and mood_match and duration_match:
                suitable_movies.append(movie["title"])

        # Если ничего не найдено, показываем случайный фильм
        if not suitable_movies:
            import random
            suitable_movies = [random.choice(movies_db)["title"]]

        # Ограничение
        movies_to_show = suitable_movies[:3]
        movies_text = "\n- ".join(movies_to_show)

        await update.message.reply_text(
            f"Вот что я нашел для тебя:\n- {movies_text}\n\n"
            f"Приятного просмотра! 🎬\n\n"
            f"Если хочешь попробовать еще раз, нажми /start",
            reply_markup=ReplyKeyboardRemove()
        )

        return ConversationHandler.END

   
 Создаём последнюю функцию main(), совмещающую в себе последовательность всех действий, что уже были прописаны.

![alt text](<Снимок экрана 2025-05-21 004413-1.png>)

В конце добавляем небольшой цикл для работы программы:

*if _ _name_ _ == "_ _main_ _":
    main()*

На этом написание программы заканчивается.

4.	Добавление конфигурации для запуска бота

Рядом с кнопкой запуска программы есть меню конфигураций, где необходимо создать новую конфигурацию

![alt text](<Снимок экрана 2025-05-21 005302-1.png>)

Главное указать правильно путь к файлу проекта. После этого нажимаем на + и с помощью новой конфигурации запускаем бота.

Результат работы:

![alt text](<Снимок экрана 2025-05-21 010037-1.png>)

###### Модификация. Функция распознавания текста.

Для оптимизации работы бота добавим функцию обработки ошибок при введении текстовых сообщений пользователем, так как для корректной работы программы необходимо, чтобы пользователь только выбирал из предложенных вариантов.
Для этого создадим функцию для обработки текста, когда диалог не начат:

*async def handle_unexpected_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    await update.message.reply_text(
        "К сожалению, не понимаю, что ты говоришь(\n"
        "Нажми /start чтобы начать диалог."
    )*

Также добавим проверки в каждое состояние на проверку того, чтобы ответ пользователя были один из вариантов:

![alt text](<Снимок экрана 2025-05-23 135426-1.png>)

Вот редактированная функция для жанра. По аналогии добавляем обработку в настроение и время.
В итоге получаем модифицированного бота:

![alt text](<Снимок экрана 2025-05-23 135848-1.png>)

На этом этапе разработка закончена.